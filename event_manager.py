import json
from datetime import datetime
from enum import Enum
from uuid import uuid4

from fastapi import APIRouter, HTTPException
from main import app

router = APIRouter()

app.include_router(
    router,
    prefix='/events',
    tags=['Events']
)


class EventStatus(str, Enum):
    NOT_STARTED = 'NOT_STARTED'
    LIVE = 'LIVE'
    STOPPED = 'STOPPED'
    FINISHED = 'FINISHED'


class EventPeriod(int, Enum):
    NOT_STARTED = 0
    FIRST_HALF_TIME = 1
    SECOND_HALF_TIME = 2


class UpdateEventMessages(str, Enum):
    NEW_EVENT = 'NEW_EVENT'
    SCORE_UPDATE = 'SCORE_UPDATE'
    PERIOD_UPDATE = 'PERIOD_UPDATE'
    STATUS_UPDATE = 'STATUS_UPDATE'
    REMOVE_EVENT = 'REMOVE_EVENT'


"""
We can define dict in two ways:
dict = {'key': 'value'}
or
dict = dict(key=value)
"""

example_event = dict(id=str(uuid4()),
                     competitors=dict(home='Home team',
                                      away='Away team'),
                     status=EventStatus.NOT_STARTED,
                     score=dict(home=1,
                                away=2),
                     period=EventPeriod.FIRST_HALF_TIME,
                     scheduled=datetime.now())

"""
We will use events_store dict to keep events data.
"""
events_store = dict(example=example_event)


@router.get('/example')
def get_event_example():
    """
    Returns example event.
    :return:{
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    key = 'example'
    if key not in events_store:
        raise HTTPException(status_code=404, detail='Example event not found.')
    return events_store.get('example')


@router.get('/')
def get_events():
    """
    Returns list and count of all events from event_store.
    :return: {
        total: int,
        events: list[
            {
                id: str,
                competitors:dict {
                    home:str,
                    away:str
                }
                status:str,
                score: dict{
                    home:int,
                    away:int
                },
                period:int,
                scheduled:str
            }
        ]
    }
    """
    return dict(total=len(events_store.keys()),
                events=list(events_store.values()))


@router.get('/{id_event}')
def get_event(id_event) -> json:
    """
    Returns event from events_store by id_event.
    :param id_event:
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: Check if event exists for given id_event by checking if it exists in events_store.
    #  Return said event if it exists, otherwise raise a HTTP Exception with 404 status code.
    # if id_event not in ...
    # TODO: Return event data.
    # return ...


@router.post('/')
def create_event(event_data: dict):
    """
    Creates and stores new event, emits NEW_EVENT message and returns event data.
    :param event_data: dict{
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: Event id is generated by using uuid4() function, it needs to be converted to str before storing.
    id_event = uuid4()

    # event = dict(status=EventStatus.NOT_STARTED,period=EventPeriod.NOT_STARTED,)

    # We shall emmit NEW_EVENT message.
    message_type = UpdateEventMessages.NEW_EVENT
    # app.sio.emmit(message_type, event) # TODO: Just uncomment

    # TODO: Return new event
    # return event


@router.put('/{id_event}')
def update_event(id_event, event_data):
    """
    Updates event and sends needed message.
    :param id_event:
    :param event_data:
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: Check if event exists. Raise HTTP exception with 404 if event is not found in event_store.

    # TODO: Update event in event_store.

    # TODO: Determine what is being changed.
    #  If score is being changed emit SCORE_UPDATE message.
    #  {id: str, score: dict{home:int, away:int}}
    #  If period is being changed emit PERIOD_UPDATE message.
    #  {id: str, period: EventPeriod}
    #  If status is being changed emit STATUS_UPDATE message.
    #  {id:str, status: EventStatus}
    # message = ...
    # message_type = ...
    # app.sio.emmit(message_type, message)
    # TODO: Return updated event
    # return event


@router.delete('/{id_event}')
def delete_event(id_event):
    """
    Deletes event from store and emits STATUS_UPDATE message, returns event.
    :param id_event:str
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: TODO: Check if event exists. Raise HTTP exception with 404 if event is not found in event_store.

    # TODO: Remove event from event_store.

    # TODO: Emit STATUS_UPDATE message, status should be FINISHED.

    # TODO: Return event.
