from datetime import datetime
from enum import Enum
from uuid import uuid4

from fastapi import HTTPException, APIRouter
from core.socket_handler import socket_manager

router = APIRouter()


class EventStatus(str, Enum):
    NOT_STARTED = 'NOT_STARTED'
    LIVE = 'LIVE'
    STOPPED = 'STOPPED'
    FINISHED = 'FINISHED'


class EventPeriod(int, Enum):
    NOT_STARTED = 0
    FIRST_HALF_TIME = 1
    SECOND_HALF_TIME = 2


class UpdateEventMessages(str, Enum):
    NEW_EVENT = 'NEW_EVENT'
    SCORE_UPDATE = 'SCORE_UPDATE'
    PERIOD_UPDATE = 'PERIOD_UPDATE'
    STATUS_UPDATE = 'STATUS_UPDATE'
    REMOVE_EVENT = 'REMOVE_EVENT'


"""
DOCS: https://www.geeksforgeeks.org/python-dictionary/
We can define dict in two ways:
dict = {'key': 'value'}
or
dict = dict(key=value)
"""
id_example_event = str(uuid4())

example_event = dict(id=id_example_event,
                     competitors=dict(home='Home team',
                                      away='Away team'),
                     status=EventStatus.NOT_STARTED,
                     score=dict(home=1,
                                away=2),
                     period=EventPeriod.FIRST_HALF_TIME,
                     scheduled=datetime.now())

"""
We will use events_store dict to keep events data.
"""
events_store = dict()
events_store.setdefault(id_example_event, example_event)


@router.get('/example')
def get_event_example():
    """
    Returns example event.
    :return:{
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    key = id_example_event
    if key not in events_store:
        raise HTTPException(status_code=404, detail='Example event not found.')
    return events_store.get(key)


@router.get('/')
def get_events():
    """
    Returns list and count of all events from event_store.
    :return: {
        total: int,
        events: list[
            {
                id: str,
                competitors:dict {
                    home:str,
                    away:str
                }
                status:str,
                score: dict{
                    home:int,
                    away:int
                },
                period:int,
                scheduled:str
            }
        ]
    }
    """
    return dict(total=len(events_store.keys()),
                events=list(events_store.values()))


@router.get('/{id_event}')
def get_event(id_event):
    """
    Returns event from events_store by id_event.
    :param id_event:
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: Check if event exists for given id_event by checking if it exists in events_store.
    #  Return said event if it exists, otherwise raise a HTTP Exception with 404 status code.
    # if id_event not in ...
    # TODO: Return event data.
    # return ...


@router.post('/')
async def create_event(event_data: dict):
    """
    Creates and stores new event, emits NEW_EVENT message and returns event data.
    :param event_data: dict{
        competitors:dict {
            home:str,
            away:str
        }
        scheduled:str
    }
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: Validate incoming data... Should we check only the structure or values also? Return HTTP exception with 422.

    # TODO: Event id is generated by using uuid4() function, it needs to be converted to str before storing.
    id_event = uuid4()

    # TODO: Add new event to event store. Maybe check if already exists
    # event = dict(status=EventStatus.NOT_STARTED, period=EventPeriod.NOT_STARTED,)
    # TODO: We need to emit NEW_EVENT message to NEW_EVENT room.
    message_type = UpdateEventMessages.NEW_EVENT
    # await socket_manager.emit(message_type, event, to='NEW_EVENT')  # TODO: Just uncomment üòÅ

    # TODO: Return new event
    # return event


@router.put('/{id_event}')
async def update_event(id_event, event_data: dict):
    """
    Updates event and sends needed message.
    :param id_event:
    :param event_data: dict {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: Check if event exists. Raise HTTP exception with 404 if event is not found in event_store.

    # TODO: Update event in event_store. Should we validate sent data?

    # TODO: Determine what is being changed.
    #  If score is being changed emit SCORE_UPDATE message.
    #  {id: str, score: dict{home:int, away:int}}
    #  If period is being changed emit PERIOD_UPDATE message.
    #  {id: str, period: EventPeriod}
    #  If status is being changed emit STATUS_UPDATE message.
    #  {id:str, status: EventStatus}
    # message = ...
    # message_type = ...
    # await socket_manager.emmit(message_type, message, to=id_event)
    # TODO: Return updated event
    # return event


@router.delete('/{id_event}')
async def delete_event(id_event):
    """
    Deletes event from store and emits STATUS_UPDATE message, returns event.
    :param id_event:str
    :return: {
        id: str,
        competitors:dict {
            home:str,
            away:str
        }
        status:str,
        score: dict{
            home:int,
            away:int
        },
        period:int,
        scheduled:str
    }
    """
    # TODO: TODO: Check if event exists. Raise HTTP exception with 404 if event is not found in event_store.
    #  Should we allow removing non-finished events?

    # TODO: Remove event from event_store.

    # TODO: Emit REMOVE_EVENT message

    # TODO: Return event.
